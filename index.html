<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WorkOrder Request</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --gap:10px; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:0; padding:12px; }
    h2 { margin:0 0 10px; }
    .row { display:grid; grid-template-columns: 160px 1fr; gap:var(--gap); align-items:center; margin-bottom:10px; }
    .row-full { display:block; margin-bottom:10px; }
    label { font-weight:600; }
    input, select, textarea, button { width:100%; padding:8px; box-sizing:border-box; }
    input[readonly] { background:#f3f4f6; }
    textarea { min-height:120px; }
    small { color:#6b7280; display:block; margin-top:4px; }
    .btns { display:flex; gap:8px; margin-top:8px; }
    button { border:0; border-radius:8px; cursor:pointer; }
    .primary { background:#2563eb; color:white; }
    #status { font-size:12px; color:#6b7280; margin-top:8px; }
    .ok { color:#065f46 !important; }
    .err { color:#7f1d1d !important; }
    /* --- AI suggestions UI --- */
.suggest-chip{margin-top:6px;padding:8px;border:1px dashed #bbb;border-radius:8px;background:#fafafa;}
.suggest-ghost{font-size:12px;opacity:.85;margin-bottom:6px;white-space:pre-wrap;}
.suggest-btn{font-size:12px;padding:6px 10px;border-radius:6px;border:1px solid #ddd;background:#fff;cursor:pointer}
.suggest-btn:hover{background:#f2f2f2}
  </style>
</head>
<body>
  <h2>Create Request in Salesforce</h2>

  <div class="row">
  <label for="projectCode">Project Code</label>
  <input id="projectCode" type="text"/>
</div>
  
  <div class="row">
    <label for="subject">Topic</label>
    <div>
      <input id="subject" type="text" placeholder='e.g., "Medical devices in China", "Breweries in Colombia"' required />
      <small>Topic of the call. Examples: “Medical devices in China”, “Breweries in Colombia”.</small>
    </div>
  </div>

  <div class="row">
    <label for="frontId">FrontID</label>
    <input id="frontId" type="text" readonly />
  </div>

  <div class="row">
    <label for="clientEmail">Client’s Email</label>
    <input id="clientEmail" type="email" placeholder="name@company.com" required />
    <small>Please make sure the contact is available in Salesforce.</small>
  </div>

  <div class="row">
    <label for="datetime">Date & Time Booking</label>
    <input id="datetime" type="datetime-local" required />
     <small>Enter the job date and time (using your system’s timezone).</small>
  </div>

  <div class="row">
    <label for="serviceType">Service Type</label>
    <select id="serviceType" required></select>
  </div>

  <div class="row">
    <label for="srcLang">Source Language</label>
    <select id="srcLang" required></select>
  </div>

  <div class="row">
    <label for="tgtLang">Target Language</label>
    <select id="tgtLang" required></select>
  </div>

  <div class="row-full">
    <label for="description">Description</label>
    <textarea id="description" placeholder="Add job context and any special details"></textarea>
    <small>Use this area to provide more details about the job.</small>
  </div>

<div class="row-full">
  <label for="dialIn">Dial-in</label>
  <textarea id="dialIn" placeholder="Paste Zoom/Teams link, phone bridge, passcode, etc."></textarea>
  <small>Zoom/Teams link or phone number.</small>
</div>


<div class="row-full">
  <label for="prepMaterials">Prep Materials</label>
  <textarea id="prepMaterials" placeholder="Links to decks, docs, or questions…"></textarea>
  <small>Discussion questions or materials.</small>
</div>


  <div class="btns">
    <button id="send" class="primary" type="button">Submit</button>
  </div>

  <div id="status">Waiting for conversation…</div>

  <!-- Front Plugin SDK -->
  <script src="https://dl.frontapp.com/libs/plugin-sdk-1.8.1.min.js"></script>
  <script>
    const ZAP_URL = "https://hooks.zapier.com/hooks/catch/9441479/uthb9na/";

    // === Extractor (LLM) Endpoint ===
const EXTRACTOR_URL = "https://g4jaycxj27ds6u62hdgize7lre0czbmu.lambda-url.us-west-2.on.aws/"; // <-- PUT YOUR LAMBDA URL

// Confidence thresholds
const CONF_AUTO = 0.75;   // auto-fill at/above
const CONF_SUGG = 0.50;   // suggest between 0.50–0.74


    // Fixed quotes on "English"
    const LANGUAGES = ["English","Mandarin","Japanese","Korean","French","Spanish","Portuguese","German","EU Portuguese","EU French","EU Spanish",
      "Afrikaans","Amazigh","Amharic","Arabic","Asturian","Azerbaijani","Bahasa Indonesia","Balinese","Basque","Brazilian Portuguese",
      "Bengali","Bosnian","Bulgarian","Burmese","Canadian French","Cantonese","Catalan","Creole","Croatian","Czech",
      "Danish","Dari","Dutch","Esperanto","Estonian","Farsi","Finnish","Flemish","Georgian","Greek",
      "Gujarati","Hakka","Hebrew","Hindi","Hmong","Hokkien","Hungarian","Italian","Javanese","Kannada",
      "Khmer","Kurdish","Latin American Spanish","Lao","Lithuanian","Macedonian","Malay","Chinese (Hongkong)","Marathi","Marshallese",
      "Mongolian","Nepalese","Norwegian","Pashto","Persian","Polish","Punjabi","Romanian","Russian","Scots",
      "Serbian","Sinhalese","Slavic","Slovak","Somali","Sundanese","Swahili","Swedish","Tagalog","Taiwanese",
      "Tamil","Telugu","Teochew","Thai","Turkish","Ukrainian","Urdu","Uyghur","Vietnamese","Other"];

    const SERVICE_TYPES = ["[CI] Interpret a call (industry discussion)",
      "[CI] Interpret a call (IR / management team)",
      "[CI] Interpret an on-site meeting",
      "[SI] Interpret a call (industry discussion)",
      "[SI] Interpret a call (IR / management team)",
      "[SI] Interpret an on-site meeting",
      "[SI] Interpret a call solo (industry discussion)",
      "[SI] Interpret a call solo (IR / management team)",
      "[SI] Interpret an on-site meeting solo",
      "Translate a document",
      "Translate a survey",
      "HITL",
      "HITL Lite",
      "Machine",
      "HITL Verbatim",
      "[IDI] Moderate a call",
      "[FGD] Moderate a call",
      "Briefing - Moderation",
      "Briefing - Interpretation",
      "[Other] Bespoke services"];

    // Exclude any addresses under these domains (e.g., all @cadencetranslate.com)
const EXCLUDE_CLIENT_DOMAINS = ["cadencetranslate.com"];


    // === Exclude internal addresses from 'Client’s email' auto-fill ===
const EXCLUDE_CLIENT_EMAILS = ["bookings@cadencetranslate.com"];

function firstNonExcludedEmail(handles) {
  const EXCLUDE = new Set(EXCLUDE_CLIENT_EMAILS.map(s => s.toLowerCase()));
  const EXCLUDE_DOMAINS = new Set(EXCLUDE_CLIENT_DOMAINS.map(s => s.toLowerCase()));

  const extractEmail = (s) => {
    if (typeof s !== "string") return "";
    // Supports plain emails or "Name <email@domain>"
    const m = s.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i);
    return m ? m[0].toLowerCase().trim() : "";
  };

  for (const h of handles || []) {
    const email = extractEmail(h);
    if (!email) continue;

    if (EXCLUDE.has(email)) continue; // exact-address exclude
    const domain = email.split("@")[1];
    if (EXCLUDE_DOMAINS.has(domain)) continue; // domain-wide exclude

    return email; // first non-excluded email wins
  }
  return "";
}


    const $ = id => document.getElementById(id);
    const el = {
      subject: $("subject"),
      frontId: $("frontId"),
      clientEmail: $("clientEmail"),
      datetime: $("datetime"),
      serviceType: $("serviceType"),
      srcLang: $("srcLang"),
      tgtLang: $("tgtLang"),
      description: $("description"),
      send: $("send"),
      status: $("status"),
      projectCode: $("projectCode"),
      dialIn: $("dialIn"),
      prepMaterials: $("prepMaterials"),

    };

    function buildSelectOptions(list) {
      return '<option value="" disabled selected>Select…</option>' +
        list.map(v => `<option value="${v}">${v}</option>`).join("");
    }
    function fillSelects() {
      el.srcLang.innerHTML = buildSelectOptions(LANGUAGES);
      el.tgtLang.innerHTML = buildSelectOptions(LANGUAGES);
      el.serviceType.innerHTML = buildSelectOptions(SERVICE_TYPES);
    }
    fillSelects();

    // ——— submitter info (Front teammate using the plugin)
    let submitter = { name: "", email: "", timezone: "" };

    // Formats "YYYY-MM-DDTHH:MM" -> "YYYY-MM-DDTHH:MM:00.000±HH:MM" using a specific IANA timeZone
function formatLocalDateTimeWithTZ(localStr, timeZone) {
  if (!localStr) return "";
  const [datePart, timePartRaw = "00:00"] = localStr.split("T");
  let [hh = "00", mm = "00", ss = "00"] = timePartRaw.split(":");
  if (!ss) ss = "00";
  const [Y, M, D] = datePart.split("-").map(n => parseInt(n, 10));
  const pad2 = v => String(v).padStart(2, "0");

  // Anchor at the same wall time in UTC, then ask Intl for the zone offset at that instant
  const utcLike = new Date(Date.UTC(Y, M - 1, D, parseInt(hh,10), parseInt(mm,10), parseInt(ss,10), 0));

  let off = "";
  try {
    const dtf = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "shortOffset",
      hour12: false,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit"
    });
    const parts = dtf.formatToParts(utcLike);
    const tzName = parts.find(p => p.type === "timeZoneName")?.value || ""; // e.g., "GMT+7"
    const m = tzName.match(/GMT([+-])(\d{1,2})(?::(\d{2}))?/);
    if (m) off = `${m[1]}${String(m[2]).padStart(2,"0")}:${(m[3]||"00").padStart(2,"0")}`;
  } catch (_) {}

  // Fallback to browser offset if shortOffset unsupported
  if (!off) {
    const tzMinutes = -utcLike.getTimezoneOffset();
    const sign = tzMinutes >= 0 ? "+" : "-";
    const offH = pad2(Math.trunc(Math.abs(tzMinutes) / 60));
    const offM = pad2(Math.abs(tzMinutes) % 60);
    off = `${sign}${offH}:${offM}`;
  }

  return `${datePart}T${pad2(hh)}:${pad2(mm)}:${pad2(ss)}.000${off}`;
}


    let ctxCache = null;
   async function detectFirstSenderEmail(ctx) {
  // Try messages (oldest inbound first)
  try {
    const page = await ctx.listMessages?.();
    const msgs = page?.results || [];

    const parsed = msgs
      .filter(m => (m.direction === "inbound" || m.status === "inbound"))
      .map(m => {
        const raw = m.created_at || m.received_at || m.date || m.inserted_at || m.createdAt || "";
        const t = Date.parse(raw);
        return { m, t: Number.isFinite(t) ? t : Number.POSITIVE_INFINITY };
      })
      .sort((a, b) => a.t - b.t);

    for (const { m } of parsed) {
      // Gather possible From/To sources on the message
      const candidates = [
        m.author?.handle,
        m.sender?.handle,
        m.recipient?.handle,
        ...(Array.isArray(m.recipients) ? m.recipients.map(r => r?.handle) : []),
        ...(Array.isArray(m.to) ? m.to.map(x => x?.handle || x?.address) : []),
        ...(Array.isArray(m.cc) ? m.cc.map(x => x?.handle || x?.address) : []),
      ].filter(Boolean);

      const email = firstNonExcludedEmail(candidates);
      if (email) return email;
    }
  } catch { /* ignore */ }

  // Fallback: conversation participants (exclude teammates and blocked address)
  try {
    const recips = await ctx.listRecipients?.();
    const arr = recips?.results || [];
    const email = firstNonExcludedEmail(
      arr
        .filter(r => r.handle?.includes("@") && r.type !== "teammate")
        .map(r => r.handle)
    );
    if (email) return email;
  } catch { /* ignore */ }

  return "";
}
// Mark fields as "user-edited" so we never overwrite their manual input
function markUserEdited(el){ el.dataset.userEdited = "1"; }
[
  el.subject, el.srcLang, el.tgtLang, el.description, el.dialIn, el.prepMaterials, el.projectCode
].forEach(x => x && x.addEventListener("input", () => markUserEdited(x)));

// Safe setters: only fill if empty & not user-edited
function setIfEmptyInput(el, val){
  if (!el || val == null) return;
  const already = (el.value || "").trim().length > 0;
  const edited = el.dataset.userEdited === "1";
  if (!already && !edited) el.value = String(val);
}

function setSelectIfEmpty(el, val){
  if (!el || !val) return;
  const edited = el.dataset.userEdited === "1";
  if (edited) return;

  // try exact match first (case-sensitive)
  const opts = Array.from(el.options);
  let found = opts.find(o => o.value === val);
  // try case-insensitive exact
  if (!found) found = opts.find(o => o.value.toLowerCase() === String(val).toLowerCase());
  // try contains either way
  if (!found) found = opts.find(o =>
    o.value.toLowerCase().includes(String(val).toLowerCase()) ||
    String(val).toLowerCase().includes(o.value.toLowerCase())
  );
  if (found && !el.value) el.value = found.value;
}

// Suggestion chips (for 0.50–0.74 confidence)
function attachSuggestion(el, val, evidence=[]){
  if (!el || !val) return;
  // prevent duplicates
  if (el.parentElement.querySelector(".suggest-chip")) return;

  const wrap = document.createElement("div");
  wrap.className = "suggest-chip";
  wrap.title = evidence && evidence.length ? ("Why: " + evidence.slice(0,2).join(" | ")) : "";

  const ghost = document.createElement("div");
  ghost.className = "suggest-ghost";
  ghost.textContent = String(val).slice(0, 500);

  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = "suggest-btn";
  btn.textContent = "Accept suggestion";
  btn.addEventListener("click", () => {
    if (el.tagName === "SELECT") {
      setSelectIfEmpty(el, val);
      // if still not matched, set raw value (so user sees it; or leave as is)
      if (!el.value) {
        // no-op; you could also append a temp <option> if you want
      }
    } else {
      el.value = String(val);
    }
    markUserEdited(el);
    wrap.remove();
  });

  wrap.appendChild(ghost);
  wrap.appendChild(btn);
  el.parentElement.appendChild(wrap);
}

// Apply a single field from extractor payload to an input/select with thresholds
function applyField(el, fieldObj){
  if (!el || !fieldObj) return;
  const val = fieldObj.value;
  const conf = typeof fieldObj.confidence === "number" ? fieldObj.confidence : 0;
  const evidence = Array.isArray(fieldObj.evidence) ? fieldObj.evidence : [];

  if (!val) return;

  if (conf >= CONF_AUTO) {
    if (el.tagName === "SELECT") setSelectIfEmpty(el, val);
    else setIfEmptyInput(el, val);
  } else if (conf >= CONF_SUGG) {
    attachSuggestion(el, val, evidence);
  }
}
async function fetchExtraction({ subject, bodyPlain, bodyHtml, senderEmail }){
  const res = await fetch(EXTRACTOR_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ subject, bodyPlain, bodyHtml, senderEmail })
  });
  if (!res.ok) {
    const t = await res.text().catch(()=> "");
    throw new Error(`Extractor HTTP ${res.status} ${res.statusText} ${t}`);
  }
  return res.json();
}

function applyExtraction(payload){
  const f = payload?.fields || {};
  // Your exact IDs
  applyField(el.subject,       f.subject);
  applyField(el.srcLang,       f.source_language);
  applyField(el.tgtLang,       f.target_language);
  applyField(el.description,   f.description);
  applyField(el.dialIn,        f.dial_in_block);
  applyField(el.prepMaterials, f.prep_materials);

  // Optional: project code (#1595297 most useful for humans)
  if (f.projectcode_raw?.value) applyField(el.projectCode, f.projectcode_raw);
  else if (f.request_id?.value) applyField(el.projectCode, { value: `#${f.request_id.value}`, confidence: f.request_id.confidence ?? 0.7, evidence: f.request_id.evidence });
}

// Public trigger (you’ll call this after you collect the latest inbound body)
async function autoFillFromEmail({ subject, bodyPlain, bodyHtml, senderEmail }){
  try {
    const data = await fetchExtraction({ subject, bodyPlain, bodyHtml, senderEmail });
    applyExtraction(data);
  } catch (e) {
    console.warn("Extractor failed:", e);
  }
}
// Get latest inbound message text (plain/HTML best-effort)
async function getLatestInboundContent(ctx){
  try {
    const page = await ctx.listMessages?.();
    const msgs = page?.results || [];

    // newest first
    const inbound = msgs
      .filter(m => (m.direction === "inbound" || m.status === "inbound"))
      .sort((a,b) => {
        const ta = Date.parse(a.created_at || a.received_at || a.date || a.inserted_at || a.createdAt || 0);
        const tb = Date.parse(b.created_at || b.received_at || b.date || b.inserted_at || b.createdAt || 0);
        return tb - ta;
      });

    for (const m of inbound) {
      // Common fields that may exist depending on channel:
      const bodyPlain = m.text || m.body || m.blurb || "";
      const bodyHtml  = m.html || "";
      if (bodyPlain || bodyHtml) return { bodyPlain, bodyHtml };
    }
  } catch (e) {
    console.warn("Could not list messages:", e);
  }
  return { bodyPlain: "", bodyHtml: "" };
}

let lastAutoFillConvId = null;

Front.contextUpdates.subscribe(async (ctx) => {
  ctxCache = ctx;

  // submitter (unchanged)
  submitter.name = ctx?.teammate?.name || "";
  submitter.email = ctx?.teammate?.email || "";
  submitter.timezone = ctx?.teammate?.timezone || (Intl.DateTimeFormat().resolvedOptions().timeZone || "");

  if (ctx?.type !== "singleConversation" || !ctx.conversation) {
    el.status.textContent = "Open a conversation to use the form.";
    return;
  }

  // Front conversation id
  el.frontId.value = ctx.conversation.id;

  // Subject (prefill from conversation if empty)
  if (!el.subject.value && ctx.conversation.subject) {
    el.subject.value = ctx.conversation.subject;
  }

  // Prefill Client email from first sender (you already had this)
  const detected = await detectFirstSenderEmail(ctx);
  if (detected && !el.clientEmail.value) {
    el.clientEmail.value = detected;
  }

  el.status.textContent = "Context loaded.";

  // === NEW: call extractor once per conversation ===
  try {
    if (lastAutoFillConvId !== ctx.conversation.id) {
      const { bodyPlain, bodyHtml } = await getLatestInboundContent(ctx);
      const subjForExtractor = el.subject.value || ctx.conversation.subject || "";
      await autoFillFromEmail({
        subject: subjForExtractor,
        bodyPlain,
        bodyHtml,
        senderEmail: detected || ""
      });
      lastAutoFillConvId = ctx.conversation.id;
    }
  } catch (e) {
    console.warn("Auto-fill error:", e);
  }
});


    function validate() {
      if (!ZAP_URL.startsWith("https://hooks.zapier.com/")) return "Set your Zapier URL in the code.";
      if (!el.subject.value.trim()) return "Subject is required.";
      if (!el.clientEmail.value.trim()) return "Client’s email is required.";
      if (!el.datetime.value.trim()) return "Date & time is required.";
      if (!el.serviceType.value) return "Service Type is required.";
      if (!el.srcLang.value) return "Source Language is required.";
      if (!el.tgtLang.value) return "Target Language is required.";
      return null;
    }

    // Submit handler (posts all fields as x-www-form-urlencoded)
    el.send.addEventListener("click", async () => {
      const err = validate();
      if (err) { el.status.textContent = err; el.status.className = "err"; return; }

      // Format datetime with submitter's offset (e.g., 2023-07-03T14:30:00.000+08:00)
      const tz = submitter.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
const datetimeWithTZ = formatLocalDateTimeWithTZ(el.datetime.value, tz);


      const body = new URLSearchParams();
      body.set("subject", el.subject.value.trim());
      body.set("front_id", el.frontId.value || "");
      if (el.frontId.value) body.set("conversation_url", `https://app.frontapp.com/open/c/${el.frontId.value}`);
      body.set("client_email", el.clientEmail.value.trim());
      body.set("datetime_local", datetimeWithTZ); // <-- formatted with offset
      body.set("service_type", el.serviceType.value);
      body.set("source_language", el.srcLang.value);
      body.set("target_language", el.tgtLang.value);
      body.set("description", el.description.value.trim());
      body.set("submitter_name", submitter.name);
      body.set("submitter_email", submitter.email);
      body.set("submitter_timezone", submitter.timezone); // IANA, e.g., "Asia/Singapore";
      body.set("project_code", el.projectCode.value.trim());
      body.set("dial_in", el.dialIn.value.trim());
      body.set("prep_materials", el.prepMaterials.value.trim())


      el.status.textContent = "Sending…";
      el.status.className = "";

      try {
        const res = await fetch(ZAP_URL, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
          body
        });

        const text = await res.text().catch(() => "");
        if (!res.ok) {
          el.status.textContent = `Submit failed: HTTP ${res.status} ${res.statusText}${text ? " — " + text : ""}`;
          el.status.className = "err";
          return;
        }
        el.status.textContent = "Submitted successfully. Please review the internal comment in this thread and verify that all request details in Salesforce are correct.";
        el.status.className = "ok";
      } catch (e) {
        el.status.textContent = `Network/CORS error: ${e?.message || e}`;
        el.status.className = "err";
      }
    });
  </script>
</body>
</html>
